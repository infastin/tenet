= Библиотека ranges =

Библиотека `ranges` была изначально создана Эриком Ниблером.
Она работает для всех версий стандарта C++ начиная с C++11.

В C++20 эта библиотека была добавлена и частично перенесена в стандартную библиотеку,
а в C++23 библиотека `ranges` будет перенесена в стандартую библиотеку полностью.

На лекции я попытаюсь объяснить, что в этой библиотеке такого особенного и
почему она заслужила честь стать частью стандартной библиотеки.

== Что это за библиотека вообще? ==

Данная библиотека добавляет концепты `range` и `view`, упрощает
взаимодействие с итерируемыми объектами, реализует все алгоритмы
из заголовочного файла `<algorithm>`, а также вводит набор "функций"
для взаимодействия с `range` и `view`.

Библиотека `ranges` значительно полагается на концепты, из-за чего
при передаче неверных параметров в функции этой библиотеки вы
будете получать куда более понятные сообщения об ошибках при компиляции,
чем "на 5000 строке в файле .../foo/bar.hpp не удалось найти подходящий метод".

== Ниблоиды ==

Очень важной частью библиотеки являются ниблоиды - функциональные объекты,
которые реализуют несколько методов `operator()`, которые за счет концептов
будут вызваны только при соблюдении передаваемыми аргументами определенных условий.

Они так были названы в честь автора библиотеки `ranges`.

Пример в виде ниблоида `ranges::begin`:
{{{cpp
namespace ranges {

namespace detail {
	template<typename T>
	concept __member_begin = requires(T &t) {
		{ t.begin() } -> std::input_or_output_iterator;
	};

	template<typename T>
	concept __adl_begin = requires(T &t) {
		{ begin(t) } -> std::input_or_output_iterator;
	};

	struct _Begin {
		template<typename T>
		requires (std::is_array_v<std::remove_reference<T>>
			&& std::is_lvalue_reference_v<T>)
			|| __member_begin<T> || __adl_begin<T>
		auto
		operator()(T &&t) const noexcept
		{
			if constexpr (std::is_array_v<std::remove_reference<T>>) {
				return t + 0;
			} else if constexpr (__member_begin<T>) {
				return t.begin();
			} else {
				return begin(t);
			}
		}
	};
}

inline namespace cust {
	inline constexpr detail::_Begin begin{};
}

}
}}}

В случае с `std::ranges::begin` реализован только один метод `operator()`.
Если тип переданного аргумента является массивом, то вернется массив.
Если тип реализует метод `begin`, то будет вызван именно он.
Если для типа где-то в коде реализована функция `begin`, то ниблоид вызовет функцию.
Ничего из выше перечисленного - получите относительно понятное сообщение об ошибке.

Зачем всё это нужно? Проблема в том, что когда нам в функцию или метод
передают какой-нибудь аргумент с шаблонным типом, мы хотим получить итератор данного
аргумента, при этом не зная наверняка, является ли данный аргумент массивом, реализует 
ли его тип соответствующий метод или же для типа была определена функция.

До этого стандартная библиотека не обладала подобным механизмом и достаточно часто
использовали подобный подход:
{{{cpp
using std::begin;
begin(arg);
}}}

Но он не подойдет, если тип реализует метод, но для
типа не определена соответствующая функция.

Но почему ниблоиды являются именно функторами? Это было
сделано ради того, чтобы ниблоид не находил сам себя при
поиске соответствующей функции с помощью ADL, поскольку
в ADL участвуют только функции.

== Концепты range и view ==

Эти концепты выглядят следующим образом:
{{{cpp
template<typename T>
concept range = requires(T& t) {
  std::ranges::begin(t);
  std::ranges::end(t);
};

template<typename T>
concept view = std::ranges::range<T>
	&& std::movable<T>
	&& std::ranges::enable_view<T>;

template<class T>
inline constexpr bool enable_view =
	std::derived_from<T, view_base> || is_derived_from_view_interface<T>;
}}}

Можно заметить, что удовлетворять концепту `range` будет любой тип данных,
для которого можно вызвать `std::ranges::begin` и `std::ranges::end`.
Данный концепт используется повсюду в библиотеке `ranges` и
по сути говорит, что по любому типу, удовлетворяющий концепту, можно итерировать.

Концепт `view` является расширением концепта `range` и он используется
различными адапторами диапазонов для построения конвееров, которые похожи
на конвееры из `bash` и других командных оболочек.

== Адапторы диапазонов ==

Адапторы диапазонов это такие структуры данных, которые
берут исходный диапазон и тем или иным образом преобразуют
входные данные исходного диапазона во что-то иное.

В качестве примера рассмотрим адаптор `filter` и фабрику диапазона `iota`:
{{{cpp
auto is_even = [](int number) -> bool { return number % 2 == 0; };

for (auto i : std::views::iota(0, 10) | std::views::filter(is_even)) {
	std::cout << i << '\n';
}
}}}

В данном примере мы создаем диапазон целых чисел [0, 10) с помощью `std::view::iota`
и отфильтровываем все нечетные числа с помощью `std::view::filter`.

Адапторы не модифицируют данные в исходном диапазоне, а лишь преобразуют их
при выводе.

Можно немного усложнить пример с помощью адаптора `std::views::transform`, а потом поместить
все трансформированные значения в вектор:
{{{cpp
std::vector<int> vec;
auto is_even = [](int number) -> bool { return number % 2 == 0; };
auto square = [](int number) -> int { return number * number; };

std::ranges::copy(std::views::iota(0, 10)
	| std::views::filter(is_even)
	| std::views::transform(square),
	std::back_inserter(vec));

for (auto i : vec) {
	std::cout << i << '\n';
}
}}}

== Пишем свою фабрику ==


